{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Pedro%20Henrique/Desktop/A-firma/website-ui/lib/server/validated.ts"],"sourcesContent":["import { promises as fs } from \"fs\";\nimport path from \"path\";\n\nfunction repoRoot() {\n  return path.resolve(process.cwd(), \"..\");\n}\n\nexport function validatedRoot() {\n  return process.env.VALIDATED_DIR || path.join(repoRoot(), \"results\", \"validated\", \"latest\");\n}\n\nexport async function readValidatedUniverse(tf: string) {\n  const file = path.join(validatedRoot(), `universe_${tf}.json`);\n  const text = await fs.readFile(file, \"utf-8\");\n  return JSON.parse(text);\n}\n\nexport async function readAssetStatusMap() {\n  const file = path.join(validatedRoot(), \"asset_status.csv\");\n  const text = await fs.readFile(file, \"utf-8\");\n  const lines = text.trim().split(\"\\n\");\n  const header = (lines.shift() || \"\").split(\",\").map((h) => h.trim());\n  const out: Record<string, Record<string, string>> = {};\n  for (const line of lines) {\n    const parts = line.split(\",\");\n    const row: Record<string, string> = {};\n    header.forEach((h, i) => {\n      row[h] = (parts[i] || \"\").trim();\n    });\n    const key = `${row.asset}__${row.timeframe}`;\n    out[key] = row;\n  }\n  return out;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,SAAS;IACP,OAAO,4GAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,IAAI;AACrC;AAEO,SAAS;IACd,OAAO,QAAQ,GAAG,CAAC,aAAa,IAAI,4GAAI,CAAC,IAAI,CAAC,YAAY,WAAW,aAAa;AACpF;AAEO,eAAe,sBAAsB,EAAU;IACpD,MAAM,OAAO,4GAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,GAAG,KAAK,CAAC;IAC7D,MAAM,OAAO,MAAM,yGAAE,CAAC,QAAQ,CAAC,MAAM;IACrC,OAAO,KAAK,KAAK,CAAC;AACpB;AAEO,eAAe;IACpB,MAAM,OAAO,4GAAI,CAAC,IAAI,CAAC,iBAAiB;IACxC,MAAM,OAAO,MAAM,yGAAE,CAAC,QAAQ,CAAC,MAAM;IACrC,MAAM,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC;IAChC,MAAM,SAAS,CAAC,MAAM,KAAK,MAAM,EAAE,EAAE,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;IACjE,MAAM,MAA8C,CAAC;IACrD,KAAK,MAAM,QAAQ,MAAO;QACxB,MAAM,QAAQ,KAAK,KAAK,CAAC;QACzB,MAAM,MAA8B,CAAC;QACrC,OAAO,OAAO,CAAC,CAAC,GAAG;YACjB,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI;QAChC;QACA,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,EAAE,EAAE,IAAI,SAAS,EAAE;QAC5C,GAAG,CAAC,IAAI,GAAG;IACb;IACA,OAAO;AACT"}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Pedro%20Henrique/Desktop/A-firma/website-ui/lib/server/data.ts"],"sourcesContent":["import { promises as fs } from \"fs\";\nimport path from \"path\";\nimport { readAssetStatusMap } from \"@/lib/server/validated\";\n\r\nfunction repoRoot() {\r\n  return path.resolve(process.cwd(), \"..\");\r\n}\r\n\r\nexport function dataDirs() {\r\n  const root = repoRoot();\r\n  return {\r\n    latest: process.env.DATA_DIR || path.join(root, \"results\", \"latest\"),\r\n    publicLatest: path.join(process.cwd(), \"public\", \"data\", \"latest\"),\r\n    results: path.join(root, \"results\"),\r\n  };\r\n}\r\n\r\nexport async function listLatestFiles() {\r\n  const { latest, publicLatest } = dataDirs();\r\n  let dir = latest;\r\n  try {\r\n    await fs.access(dir);\r\n  } catch {\r\n    dir = publicLatest;\r\n  }\r\n  const files = await fs.readdir(dir);\r\n  return files.filter((f) => f.endsWith(\".json\"));\r\n}\r\n\r\nexport async function readLatestFile(file: string) {\r\n  const { latest, publicLatest } = dataDirs();\r\n  let dir = latest;\r\n  try {\r\n    await fs.access(dir);\r\n  } catch {\r\n    dir = publicLatest;\r\n  }\r\n  const target = path.join(dir, file);\r\n  try {\r\n    const text = await fs.readFile(target, \"utf-8\");\r\n    return JSON.parse(text);\r\n  } catch {\r\n    // fallback: try other dir\r\n    const fallback = dir === latest ? path.join(publicLatest, file) : path.join(latest, file);\r\n    const text = await fs.readFile(fallback, \"utf-8\");\r\n    return JSON.parse(text);\r\n  }\r\n}\r\n\r\nexport async function findLatestApiRecords() {\n  const { results } = dataDirs();\n  // Preferred source: ops snapshots (production-gated payload).\n  const snapshotsRoot = path.join(results, \"ops\", \"snapshots\");\n  try {\n    const runDirs = await fs.readdir(snapshotsRoot, { withFileTypes: true });\n    const snapCandidates: { path: string; mtime: number }[] = [];\n    for (const ent of runDirs) {\n      if (!ent.isDirectory()) continue;\n      const p = path.join(snapshotsRoot, ent.name, \"api_snapshot.jsonl\");\n      try {\n        const stat = await fs.stat(p);\n        snapCandidates.push({ path: p, mtime: stat.mtimeMs });\n      } catch {\n        // ignore\n      }\n    }\n    snapCandidates.sort((a, b) => b.mtime - a.mtime);\n    if (snapCandidates.length) return snapCandidates[0].path;\n  } catch {\n    // ignore and fallback to legacy search\n  }\n\n  // Legacy fallback: results/*/api_records.jsonl\n  const entries = await fs.readdir(results, { withFileTypes: true });\n  const candidates: { path: string; mtime: number }[] = [];\n  for (const ent of entries) {\n    if (!ent.isDirectory()) continue;\r\n    const p = path.join(results, ent.name, \"api_records.jsonl\");\r\n    try {\r\n      const stat = await fs.stat(p);\r\n      candidates.push({ path: p, mtime: stat.mtimeMs });\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n  candidates.sort((a, b) => b.mtime - a.mtime);\r\n  return candidates.length ? candidates[0].path : null;\r\n}\r\n\r\nexport async function readJsonl(pathFile: string) {\n  const text = await fs.readFile(pathFile, \"utf-8\");\r\n  return text\r\n    .split(\"\\n\")\r\n    .map((line) => line.trim())\r\n    .filter(Boolean)\r\n    .map((line) => JSON.parse(line));\n}\n\nexport type LatestRunInfo = {\n  runId: string;\n  snapshotPath: string;\n  summaryPath: string;\n  summary: Record<string, unknown>;\n};\n\nfunction isRunValid(summary: Record<string, unknown>) {\n  const status = String(summary?.status || \"\").toLowerCase();\n  const gate = (summary?.deployment_gate || {}) as Record<string, unknown>;\n  const blocked = gate?.blocked === true;\n  return status === \"ok\" && !blocked;\n}\n\nexport async function findLatestValidRun(): Promise<LatestRunInfo | null> {\n  const { results } = dataDirs();\n  const snapshotsRoot = path.join(results, \"ops\", \"snapshots\");\n  let runDirs: string[] = [];\n  try {\n    runDirs = (await fs.readdir(snapshotsRoot, { withFileTypes: true }))\n      .filter((ent) => ent.isDirectory())\n      .map((ent) => ent.name)\n      .sort()\n      .reverse();\n  } catch {\n    return null;\n  }\n\n  for (const runId of runDirs) {\n    const summaryPath = path.join(snapshotsRoot, runId, \"summary.json\");\n    const snapshotPath = path.join(snapshotsRoot, runId, \"api_snapshot.jsonl\");\n    try {\n      const [summaryText, snapshotStat] = await Promise.all([fs.readFile(summaryPath, \"utf-8\"), fs.stat(snapshotPath)]);\n      if (!snapshotStat.size) continue;\n      const summary = JSON.parse(summaryText) as Record<string, unknown>;\n      if (!isRunValid(summary)) continue;\n      return { runId, summaryPath, snapshotPath, summary };\n    } catch {\n      // ignore invalid run and keep scanning older runs\n    }\n  }\n  return null;\n}\n\nexport async function readLatestSnapshot() {\n  const run = await findLatestValidRun();\n  if (!run) return null;\n  const records = await readJsonl(run.snapshotPath);\n  return {\n    runId: run.runId,\n    summary: run.summary,\n    records,\n  };\n}\n\nexport async function readRiskTruthPanel() {\n  const { results } = dataDirs();\n  const target = path.join(results, \"validation\", \"risk_truth_panel.json\");\n  try {\n    const text = await fs.readFile(target, \"utf-8\");\n    return JSON.parse(text);\n  } catch {\n    return {\n      status: \"empty\",\n      counts: { assets: 0, validated: 0, watch: 0, inconclusive: 0 },\n      entries: [],\n    };\n  }\n}\n\nexport async function readGlobalVerdict() {\n  const { results } = dataDirs();\n  const target = path.join(results, \"validation\", \"VERDICT.json\");\n  try {\n    const text = await fs.readFile(target, \"utf-8\");\n    return JSON.parse(text);\n  } catch {\n    return { status: \"unknown\", gate_checks: {} };\n  }\n}\n\nexport async function readJsonlWithValidationGate(pathFile: string) {\n  const records = await readJsonl(pathFile);\n  let statusMap: Record<string, Record<string, string>> = {};\n  try {\n    statusMap = await readAssetStatusMap();\n  } catch {\n    return records;\n  }\n  return records.map((record) => {\n    const key = `${record.asset || \"\"}__${record.timeframe || \"\"}`;\n    const gate = statusMap[key];\n    if (!gate || (gate.status || \"\").toLowerCase() === \"validated\") {\n      return record;\n    }\n    const reason = gate.reason || \"gate_not_validated\";\n    const warnings = Array.isArray(record.warnings) ? [...record.warnings] : [];\n    if (!warnings.includes(\"INCONCLUSIVE_SIGNAL\")) {\n      warnings.push(\"INCONCLUSIVE_SIGNAL\");\n    }\n    return {\n      ...record,\n      signal_status: \"inconclusive\",\n      use_forecast_bool: false,\n      action: \"DIAGNOSTICO_INCONCLUSIVO\",\n      regime_label: \"INCONCLUSIVE\",\n      confidence_level: \"LOW\",\n      warnings,\n      gate_reason: reason,\n    };\n  });\n}\n\r\nexport async function readDashboardOverview() {\r\n  const { results } = dataDirs();\r\n  const overviewPath = path.join(results, \"dashboard\", \"overview.json\");\r\n  const text = await fs.readFile(overviewPath, \"utf-8\");\r\n  return JSON.parse(text);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Pedro%20Henrique/Desktop/A-firma/website-ui/app/api/run/latest/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { findLatestValidRun, readGlobalVerdict } from \"@/lib/server/data\";\n\nexport async function GET() {\n  const [run, verdict] = await Promise.all([findLatestValidRun(), readGlobalVerdict()]);\n  if (!run) {\n    return NextResponse.json(\n      {\n        error: \"no_valid_run\",\n        message: \"Nenhum run valido encontrado (status ok + deployment gate liberado).\",\n      },\n      { status: 503 }\n    );\n  }\n\n  return NextResponse.json({\n    run_id: run.runId,\n    summary: run.summary,\n    global_verdict_status: verdict?.status || \"unknown\",\n  });\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe;IACpB,MAAM,CAAC,KAAK,QAAQ,GAAG,MAAM,QAAQ,GAAG,CAAC;QAAC,IAAA,6IAAkB;QAAI,IAAA,4IAAiB;KAAG;IACpF,IAAI,CAAC,KAAK;QACR,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS;QACX,GACA;YAAE,QAAQ;QAAI;IAElB;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB,QAAQ,IAAI,KAAK;QACjB,SAAS,IAAI,OAAO;QACpB,uBAAuB,SAAS,UAAU;IAC5C;AACF"}}]
}